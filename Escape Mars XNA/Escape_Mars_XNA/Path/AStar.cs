using System;
using System.Collections.Generic;
using System.Linq;
using Escape_Mars_XNA.Helper;

namespace Escape_Mars_XNA.Path
{
    public class AStar
    {
        // Subject graph for searching
        public Graph Graph { get; private set; }

        // Indexes by node index. Contains the "real" cumulative
        // cost to that node
        private double[] _gCosts;

        // Indexed by node index. Contains the cost from
        // adding _gCosts[n] the heuristic cost from n to
        // the target node. This is the vector the priorityQueue indexes into
        private double[] _fCosts;

        private GraphEdge[] _shortestPathTree;

        private GraphEdge[] _searchFrontier;

        private PriorityQueue _priorityQueue;

        private GraphNode _source;
        private GraphNode _target;

        // Constructor
        public AStar(Graph graph)
        {
            Graph = graph;
        }

        public void Search(GraphNode source, GraphNode target)
        {
            if (source == null || target == null)
            {
                return;
            }
            if (!source.Active || !target.Active)
            {
                return;
            }
            _source = source;
            _target = target;
            
            InitializeStructures();

            _priorityQueue.Enqueue(new PriorityQueueElement(0, _source));

            while (!_priorityQueue.IsEmpty())
            {
                var ncn = _priorityQueue.Dequeue();

                var ncnNode = ncn.Node;
                var ncnIdx = ncn.Node.Index;

                if (!ncnNode.Active) continue;

                // Move node from the frontier to the spanning tree
                _shortestPathTree[ncnIdx] = _searchFrontier[ncnIdx];
                

                // If target found then return
                if (ncnIdx == _target.Index) return;

                foreach (var edge in ncnNode.Edges)
                {
                    var eIdx = edge.To.Index;
                    // Calculate heuristic cost from neighbour node to
                    // target
                    var hCost = Calculate(_target, edge.To);

                    // Calculate the real cost to neighbour from the 
                    // source
                    var gCost = _gCosts[ncnIdx] + edge.Cost;

                    // A* cost from neighbour node to target
                    var fCost = hCost + gCost;

                    // If node not visited yet
                    if (_searchFrontier[eIdx] == null)
                    {
                        _fCosts[eIdx] = fCost;
                        _gCosts[eIdx] = gCost;

                        _priorityQueue.Enqueue(new PriorityQueueElement(fCost, edge.To));

                        _searchFrontier[eIdx] = Graph.GetEdge(edge.From, edge.To);
                    }
                    else
                    {
                        if (gCost < _gCosts[eIdx] &&
                            _shortestPathTree[eIdx] == null)
                        {
                            _fCosts[eIdx] = fCost;
                            _gCosts[eIdx] = gCost;

                            _priorityQueue.ChangePriority(gCost, edge.To);

                            _searchFrontier[eIdx] = Graph.GetEdge(edge.From, edge.To);
                        }
                    }
                }
            }
        }

        private void InitializeStructures()
        {
            var numNodes = Graph.NumNodes();

            _fCosts = new double[numNodes];
            _gCosts = new double[numNodes];

            _priorityQueue = new PriorityQueue(numNodes);

            _shortestPathTree = new GraphEdge[numNodes];

            _searchFrontier = new GraphEdge[numNodes];
        }

        // Set the graph that the AStar is using
        public void SetGraph(Graph graph)
        {
            Graph = graph;
        }

        // Calculate the Euclidean distance between two nodes
        private static double Calculate(GraphNode node1, GraphNode node2)
        {
            // Dividing with 32 is required because that is the width and height of a grid
            return Vector2Helper.Distance(node1.Position, node2.Position) / 32;
        }

        public List<GraphEdge> GetMinSpTree()
        {
            return _shortestPathTree == null ? null : _shortestPathTree.Where(e => e != null).ToList();
        }

        // Return the path from source to target generated by A*
        public List<GraphEdge> GetPath()
        {
            var path = new List<GraphEdge>();

            if (_source.Index == _target.Index) return path;

            var index = _target.Index;

            while (_shortestPathTree[index].From.Index != _source.Index)
            {
                var edge = _shortestPathTree[index];

                path.Add(edge);

                index = edge.From.Index;
            }

            path.Add(_shortestPathTree[index]);

            path.Reverse();

            return path;
        }

        // Return the cost of the calculated path
        public double GetCost()
        {
            var path = GetPath();
            return path.Sum(edge => edge.Cost);
        }
    }
}
